"""
Professional Penetration Testing GUI - Google Dorking Module
Enterprise-grade Google dorking tool for security professionals
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog, scrolledtext
import threading
import time
import random
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
import logging
import json
from pathlib import Path

# Import our optimized modules
from hybrid_scraper_fixed import HybridScraper
from fast_bulk_scanner import FastBulkScanner
from analysis import ResultAnalyzer
from google_dorks import get_all_dorks_for_domain, GOOGLE_DORKS
from scraper import GoogleScraper
try:
    from export import ResultExporter
    EXPORT_AVAILABLE = True
except ImportError:
    EXPORT_AVAILABLE = False
    print("⚠️  Export functionality not available (install reportlab for PDF export)")

class ProfessionalPentestGUI:
    def __init__(self, master):
        self.master = master
        self.master.title("Professional Penetration Testing Suite - Google Dorking Module")
        self.master.geometry("1400x900")
        
        # Professional configuration
        self.config = {
            'delay_range': (0.5, 1.5),  # Conservative for enterprise use
            'max_workers': 6,           # Balanced performance
            'timeout': 10,              # Reasonable timeout
            'batch_size': 15            # Moderate batch size
        }
        
        # Initialize components
        self.hybrid_scraper = HybridScraper(delay_range=self.config['delay_range'])
        self.fast_scanner = FastBulkScanner(
            max_workers=self.config['max_workers'], 
            delay_range=self.config['delay_range']
        )
        self.analyzer = ResultAnalyzer()
        self.google_scraper = GoogleScraper(delay_range=self.config['delay_range'])
        
        # Initialize exporter if available
        if EXPORT_AVAILABLE:
            self.exporter = ResultExporter()
        else:
            self.exporter = None
        
        # State management
        self.is_scanning = False
        self.current_results = {}
        self.scan_start_time = None
        
        self.setup_professional_gui()
        self.load_professional_styles()
        
    def setup_professional_gui(self):
        """Setup professional-grade GUI interface"""
        
        # Main container with padding
        main_container = ttk.Frame(self.master, padding="15")
        main_container.pack(fill=tk.BOTH, expand=True)
        
        # Header section
        self.create_header_section(main_container)
        
        # Main notebook for different modules
        self.notebook = ttk.Notebook(main_container)
        self.notebook.pack(fill=tk.BOTH, expand=True, pady=(15, 0))
        
        # Comprehensive Scan tab
        self.setup_comprehensive_scan_tab()
        
        # Targeted Scan tab  
        self.setup_targeted_scan_tab()
        
        # Bulk Assessment tab
        self.setup_bulk_assessment_tab()
        
        # Configuration tab
        self.setup_configuration_tab()
        
        # Results Analysis tab
        self.setup_results_analysis_tab()
        
    def create_header_section(self, parent):
        """Create professional header section"""
        header_frame = ttk.Frame(parent)
        header_frame.pack(fill=tk.X, pady=(0, 15))
        
        # Title and description
        title_label = ttk.Label(
            header_frame, 
            text="Professional Penetration Testing Suite",
            font=('Segoe UI', 18, 'bold'),
            foreground='#2c3e50'
        )
        title_label.pack(anchor=tk.W)
        
        subtitle_label = ttk.Label(
            header_frame,
            text="Comprehensive Google Dorking & Information Gathering Module",
            font=('Segoe UI', 11),
            foreground='#7f8c8d'
        )
        subtitle_label.pack(anchor=tk.W, pady=(2, 0))
        
        # Status indicator
        status_frame = ttk.Frame(header_frame)
        status_frame.pack(fill=tk.X, pady=(10, 0))
        
        self.status_indicator = ttk.Label(
            status_frame,
            text="● Ready",
            font=('Segoe UI', 10, 'bold'),
            foreground='#27ae60'
        )
        self.status_indicator.pack(side=tk.LEFT)
        
        self.scan_info_label = ttk.Label(
            status_frame,
            text="System initialized - Ready for reconnaissance",
            font=('Segoe UI', 10),
            foreground='#7f8c8d'
        )
        self.scan_info_label.pack(side=tk.LEFT, padx=(10, 0))
        
    def setup_comprehensive_scan_tab(self):
        """Setup comprehensive scanning interface"""
        comp_frame = ttk.Frame(self.notebook)
        self.notebook.add(comp_frame, text="Comprehensive Scan")
        
        # Target configuration
        target_frame = ttk.LabelFrame(comp_frame, text="Target Configuration", padding="15")
        target_frame.pack(fill=tk.X, padx=15, pady=15)
        
        ttk.Label(target_frame, text="Target Domain:", font=('Segoe UI', 10, 'bold')).pack(anchor=tk.W)
        self.target_entry = ttk.Entry(target_frame, font=('Segoe UI', 11), width=50)
        self.target_entry.pack(fill=tk.X, pady=(5, 10))
        
        # Scan options
        options_frame = ttk.Frame(target_frame)
        options_frame.pack(fill=tk.X)
        
        self.comprehensive_mode = tk.BooleanVar(value=True)
        ttk.Checkbutton(
            options_frame, 
            text="Enable comprehensive reconnaissance (all 22 categories)",
            variable=self.comprehensive_mode
        ).pack(anchor=tk.W)
        
        self.include_hybrid = tk.BooleanVar(value=True)
        ttk.Checkbutton(
            options_frame,
            text="Include hybrid analysis (direct site probing)",
            variable=self.include_hybrid
        ).pack(anchor=tk.W)
        
        self.stealth_mode = tk.BooleanVar(value=False)
        ttk.Checkbutton(
            options_frame,
            text="Stealth mode (increased delays, reduced detection risk)",
            variable=self.stealth_mode
        ).pack(anchor=tk.W)
        
        # Control buttons
        control_frame = ttk.Frame(comp_frame)
        control_frame.pack(fill=tk.X, padx=15, pady=10)
        
        self.start_button = ttk.Button(
            control_frame,
            text="Start Comprehensive Scan",
            command=self.start_comprehensive_scan,
            style='Professional.TButton'
        )
        self.start_button.pack(side=tk.LEFT)
        
        self.stop_button = ttk.Button(
            control_frame,
            text="Stop Scan",
            command=self.stop_scan,
            state=tk.DISABLED
        )
        self.stop_button.pack(side=tk.LEFT, padx=(10, 0))
        
        # Progress section
        progress_frame = ttk.LabelFrame(comp_frame, text="Scan Progress", padding="15")
        progress_frame.pack(fill=tk.X, padx=15, pady=10)
        
        self.progress_text = ttk.Label(
            progress_frame,
            text="Ready to begin comprehensive reconnaissance",
            font=('Segoe UI', 10)
        )
        self.progress_text.pack(anchor=tk.W)
        
        self.progress_bar = ttk.Progressbar(
            progress_frame,
            mode='determinate',
            style='Professional.Horizontal.TProgressbar'
        )
        self.progress_bar.pack(fill=tk.X, pady=(10, 0))
        
        # Results display
        results_frame = ttk.LabelFrame(comp_frame, text="Reconnaissance Results", padding="15")
        results_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)
        
        self.results_text = scrolledtext.ScrolledText(
            results_frame,
            height=20,
            font=('Consolas', 9),
            wrap=tk.WORD,
            bg='#fafafa',
            fg='#2c3e50'
        )
        self.results_text.pack(fill=tk.BOTH, expand=True)
        
        # Export section
        export_frame = ttk.Frame(results_frame)
        export_frame.pack(fill=tk.X, pady=(15, 0))
        
        ttk.Button(export_frame, text="Export JSON", command=self.export_json).pack(side=tk.RIGHT)
        if EXPORT_AVAILABLE:
            ttk.Button(export_frame, text="Export CSV", command=self.export_csv).pack(side=tk.RIGHT, padx=(0, 10))
            ttk.Button(export_frame, text="Export PDF Report", command=self.export_pdf).pack(side=tk.RIGHT, padx=(0, 10))
    
    def setup_targeted_scan_tab(self):
        """Setup targeted scanning with category selection"""
        target_frame = ttk.Frame(self.notebook)
        self.notebook.add(target_frame, text="Targeted Scan")
        
        # Instructions
        info_frame = ttk.Frame(target_frame, padding="15")
        info_frame.pack(fill=tk.X)
        
        info_text = ttk.Label(
            info_frame,
            text="Select specific reconnaissance categories for focused intelligence gathering",
            font=('Segoe UI', 11),
            foreground='#7f8c8d'
        )
        info_text.pack(anchor=tk.W)
        
        # Category selection
        categories_frame = ttk.LabelFrame(target_frame, text="Select Categories", padding="15")
        categories_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=15)
        
        # Create scrollable frame for categories
        canvas = tk.Canvas(categories_frame, bg='white')
        scrollbar = ttk.Scrollbar(categories_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Add category checkboxes
        self.category_vars = {}
        categories_list = list(GOOGLE_DORKS.keys())
        
        # Organize in columns
        cols = 3
        for i, category in enumerate(categories_list):
            row = i // cols
            col = i % cols
            
            var = tk.BooleanVar()
            self.category_vars[category] = var
            
            cb = ttk.Checkbutton(
                scrollable_frame,
                text=f"{category} ({len(GOOGLE_DORKS[category])} queries)",
                variable=var
            )
            cb.grid(row=row, column=col, sticky=tk.W, padx=10, pady=5)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Select all/none buttons
        button_frame = ttk.Frame(target_frame)
        button_frame.pack(fill=tk.X, padx=15, pady=10)
        
        ttk.Button(button_frame, text="Select All", command=self.select_all_categories).pack(side=tk.LEFT)
        ttk.Button(button_frame, text="Select None", command=self.select_no_categories).pack(side=tk.LEFT, padx=(10, 0))
        ttk.Button(button_frame, text="Start Targeted Scan", command=self.start_targeted_scan).pack(side=tk.RIGHT)
    
    def setup_bulk_assessment_tab(self):
        """Setup bulk domain assessment"""
        bulk_frame = ttk.Frame(self.notebook)
        self.notebook.add(bulk_frame, text="Bulk Assessment")
        
        # Domain input
        input_frame = ttk.LabelFrame(bulk_frame, text="Target Domains", padding="15")
        input_frame.pack(fill=tk.X, padx=15, pady=15)
        
        ttk.Label(input_frame, text="Enter domains (one per line):", font=('Segoe UI', 10, 'bold')).pack(anchor=tk.W)
        
        self.bulk_domains_text = scrolledtext.ScrolledText(input_frame, height=8, font=('Segoe UI', 10))
        self.bulk_domains_text.pack(fill=tk.BOTH, expand=True, pady=(5, 10))
        
        # File operations
        file_frame = ttk.Frame(input_frame)
        file_frame.pack(fill=tk.X)
        
        ttk.Button(file_frame, text="Load from File", command=self.load_domains_file).pack(side=tk.LEFT)
        ttk.Button(file_frame, text="Clear", command=self.clear_domains).pack(side=tk.LEFT, padx=(10, 0))
        ttk.Button(file_frame, text="Start Bulk Assessment", command=self.start_bulk_assessment).pack(side=tk.RIGHT)
        
        # Progress tracking
        progress_frame = ttk.LabelFrame(bulk_frame, text="Assessment Progress", padding="15")
        progress_frame.pack(fill=tk.X, padx=15, pady=10)
        
        self.bulk_progress_label = ttk.Label(progress_frame, text="Ready for bulk assessment")
        self.bulk_progress_label.pack(anchor=tk.W)
        
        self.bulk_progress_bar = ttk.Progressbar(progress_frame, mode='determinate')
        self.bulk_progress_bar.pack(fill=tk.X, pady=(10, 0))
        
        # Results
        bulk_results_frame = ttk.LabelFrame(bulk_frame, text="Assessment Results", padding="15")
        bulk_results_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)
        
        self.bulk_results_text = scrolledtext.ScrolledText(
            bulk_results_frame,
            height=15,
            font=('Consolas', 9),
            bg='#fafafa'
        )
        self.bulk_results_text.pack(fill=tk.BOTH, expand=True)
    
    def setup_configuration_tab(self):
        """Setup configuration options"""
        config_frame = ttk.Frame(self.notebook)
        self.notebook.add(config_frame, text="Configuration")
        
        # Performance settings
        perf_frame = ttk.LabelFrame(config_frame, text="Performance Settings", padding="15")
        perf_frame.pack(fill=tk.X, padx=15, pady=15)
        
        # Delay settings
        delay_frame = ttk.Frame(perf_frame)
        delay_frame.pack(fill=tk.X, pady=5)
        
        ttk.Label(delay_frame, text="Request Delay (seconds):", font=('Segoe UI', 10, 'bold')).pack(anchor=tk.W)
        
        delay_input_frame = ttk.Frame(delay_frame)
        delay_input_frame.pack(fill=tk.X, pady=5)
        
        ttk.Label(delay_input_frame, text="Min:").pack(side=tk.LEFT)
        self.min_delay_var = tk.DoubleVar(value=self.config['delay_range'][0])
        ttk.Entry(delay_input_frame, textvariable=self.min_delay_var, width=10).pack(side=tk.LEFT, padx=(5, 15))
        
        ttk.Label(delay_input_frame, text="Max:").pack(side=tk.LEFT)
        self.max_delay_var = tk.DoubleVar(value=self.config['delay_range'][1])
        ttk.Entry(delay_input_frame, textvariable=self.max_delay_var, width=10).pack(side=tk.LEFT, padx=(5, 0))
        
        # Workers
        workers_frame = ttk.Frame(perf_frame)
        workers_frame.pack(fill=tk.X, pady=10)
        
        ttk.Label(workers_frame, text="Concurrent Workers:", font=('Segoe UI', 10, 'bold')).pack(anchor=tk.W)
        self.max_workers_var = tk.IntVar(value=self.config['max_workers'])
        workers_scale = ttk.Scale(workers_frame, from_=1, to=12, variable=self.max_workers_var, orient=tk.HORIZONTAL)
        workers_scale.pack(fill=tk.X, pady=5)
        
        self.workers_label = ttk.Label(workers_frame, text=f"Current: {self.config['max_workers']} workers")
        self.workers_label.pack(anchor=tk.W)
        workers_scale.configure(command=self.update_workers_label)
        
        # Save configuration
        ttk.Button(perf_frame, text="Apply Configuration", command=self.save_configuration).pack(pady=10)
        
        # Statistics
        stats_frame = ttk.LabelFrame(config_frame, text="Current Configuration", padding="15")
        stats_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)
        
        self.config_display = tk.Text(stats_frame, height=15, font=('Consolas', 9), bg='#f8f9fa', state=tk.DISABLED)
        self.config_display.pack(fill=tk.BOTH, expand=True)
        
        self.update_config_display()
    
    def setup_results_analysis_tab(self):
        """Setup results analysis and reporting"""
        analysis_frame = ttk.Frame(self.notebook)
        self.notebook.add(analysis_frame, text="Results Analysis")
        
        ttk.Label(
            analysis_frame,
            text="Detailed analysis and reporting capabilities will be displayed here after scans complete",
            font=('Segoe UI', 11),
            foreground='#7f8c8d'
        ).pack(expand=True)
    
    def load_professional_styles(self):
        """Load professional styling"""
        style = ttk.Style()
        
        # Configure professional button style
        style.configure(
            'Professional.TButton',
            font=('Segoe UI', 10, 'bold'),
            foreground='white',
            background='#3498db',
            borderwidth=0,
            focuscolor='none'
        )
        
        # Configure progress bar
        style.configure(
            'Professional.Horizontal.TProgressbar',
            background='#3498db',
            troughcolor='#ecf0f1',
            borderwidth=0,
            lightcolor='#3498db',
            darkcolor='#2980b9'
        )
    
    def start_comprehensive_scan(self):
        """Start comprehensive reconnaissance scan"""
        domain = self.target_entry.get().strip()
        if not domain:
            messagebox.showerror("Error", "Please enter a target domain")
            return
        
        self.is_scanning = True
        self.start_button.config(state=tk.DISABLED)
        self.stop_button.config(state=tk.NORMAL)
        self.update_status("Scanning", f"Comprehensive reconnaissance of {domain} in progress...")
        
        # Apply stealth mode if selected
        if self.stealth_mode.get():
            self.config['delay_range'] = (2.0, 4.0)
            self.config['max_workers'] = 3
        else:
            self.config['delay_range'] = (0.5, 1.5)
            self.config['max_workers'] = 6
        
        # Reinitialize components with updated config
        self.google_scraper = GoogleScraper(delay_range=self.config['delay_range'])
        
        # Start scan in thread
        scan_thread = threading.Thread(target=self.run_comprehensive_scan, args=(domain,))
        scan_thread.daemon = True
        scan_thread.start()
    
    def run_comprehensive_scan(self, domain):
        """Execute comprehensive reconnaissance scan"""
        try:
            self.update_progress_text(f"Initializing comprehensive scan for {domain}")
            
            all_results = {}
            scan_start_time = time.time()
            
            # Clean domain
            domain = domain.replace('http://', '').replace('https://', '').replace('www.', '')
            
            # Get all dork categories
            all_dorks = get_all_dorks_for_domain(domain)
            total_queries = sum(len(dorks) for dorks in all_dorks.values())
            current_query = 0
            
            self.update_progress_text(f"Starting reconnaissance: {total_queries} queries across {len(all_dorks)} categories")
            self.progress_bar.config(maximum=total_queries)
            
            # Execute comprehensive dorking
            for category, dorks in all_dorks.items():
                if not self.is_scanning:
                    break
                
                self.update_progress_text(f"Scanning {category} ({len(dorks)} queries)")
                category_results = {}
                
                # Use parallel processing for speed
                with ThreadPoolExecutor(max_workers=min(self.config['max_workers'], len(dorks))) as executor:
                    futures = {executor.submit(self.google_scraper.search_google, dork, 10): dork for dork in dorks}
                    
                    for future in as_completed(futures):
                        if not self.is_scanning:
                            break
                        
                        dork = futures[future]
                        current_query += 1
                        
                        try:
                            results = future.result()
                            category_results[dork] = results
                            
                            # Update progress
                            progress = (current_query / total_queries) * 100
                            self.update_progress_text(f"[{current_query}/{total_queries}] {category}: {len(results)} results ({progress:.0f}%)")
                            self.progress_bar.config(value=current_query)
                            
                        except Exception as e:
                            logging.error(f"Query failed: {dork} - {e}")
                            category_results[dork] = []
                
                if category_results:
                    all_results[category] = category_results
            
            # Include hybrid analysis if enabled
            if self.include_hybrid.get() and self.is_scanning:
                self.update_progress_text("Performing hybrid analysis...")
                try:
                    hybrid_results = self.hybrid_scraper.analyze_domain_directly(domain)
                    if hybrid_results:
                        if 'Login & Admin Pages' not in all_results:
                            all_results['Login & Admin Pages'] = {}
                        all_results['Login & Admin Pages'][f'Hybrid analysis of {domain}'] = hybrid_results
                except Exception as e:
                    logging.error(f"Hybrid analysis failed: {e}")
            
            total_time = time.time() - scan_start_time
            
            # Analyze results
            if all_results and self.is_scanning:
                self.update_progress_text("Analyzing reconnaissance results...")
                analyzed_results = self.analyze_comprehensive_results(all_results)
                self.current_results = analyzed_results
                self.display_professional_results(analyzed_results, total_time, domain)
            
            self.update_status("Complete", f"Reconnaissance completed in {total_time:.1f}s")
            
        except Exception as e:
            self.update_status("Error", f"Scan failed: {str(e)}")
            logging.error(f"Comprehensive scan error: {e}")
        
        finally:
            self.master.after(0, self.reset_scan_ui)
    
    def analyze_comprehensive_results(self, raw_results):
        """Analyze comprehensive results"""
        analyzed_results = {}
        all_findings = []
        total_results = 0
        category_stats = {}
        
        for category, category_results in raw_results.items():
            analyzed_category = {}
            category_count = 0
            
            for query, results in category_results.items():
                analyzed_query_results = []
                
                # Process results
                for result in results:
                    try:
                        analyzed_result = self.analyzer.analyze_result(result.copy())
                        analyzed_query_results.append(analyzed_result)
                        all_findings.append(analyzed_result)
                        category_count += 1
                    except Exception as e:
                        logging.error(f"Analysis failed: {e}")
                
                analyzed_category[query] = analyzed_query_results
                total_results += len(results)
            
            analyzed_results[category] = analyzed_category
            category_stats[category] = category_count
        
        # Calculate comprehensive metrics
        login_pages = [f for f in all_findings if 'login_page' in f.get('analysis', {}).get('categories', [])]
        high_risk = [f for f in all_findings if f.get('analysis', {}).get('risk_level') == 'high']
        sensitive_files = [f for f in all_findings if 'sensitive_file' in f.get('analysis', {}).get('categories', [])]
        
        # Add summary
        analyzed_results['_summary'] = {
            'total_queries': sum(len(dorks) for dorks in raw_results.values()),
            'total_results': total_results,
            'total_findings': len(all_findings),
            'categories_scanned': len(raw_results),
            'login_pages_count': len(login_pages),
            'sensitive_files_count': len(sensitive_files),
            'high_risk_count': len(high_risk),
            'category_breakdown': category_stats,
            'login_pages': login_pages,
            'sensitive_files': sensitive_files,
            'high_risk_findings': high_risk
        }
        
        return analyzed_results
    
    def display_professional_results(self, results, scan_time, domain):
        """Display results in professional format"""
        self.results_text.delete(1.0, tk.END)
        
        summary = results.get('_summary', {})
        
        # Professional header
        header = f"""PENETRATION TESTING RECONNAISSANCE REPORT
{'=' * 70}
Target Domain: {domain}
Scan Duration: {scan_time:.2f} seconds
Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
Scanner: Professional Dorking Module v2.0
{'=' * 70}

EXECUTIVE SUMMARY:
Total Queries Executed: {summary.get('total_queries', 0)}
Categories Scanned: {summary.get('categories_scanned', 0)}/22
Total Results Found: {summary.get('total_results', 0)}
High-Risk Findings: {summary.get('high_risk_count', 0)}
Login/Admin Pages: {summary.get('login_pages_count', 0)}
Sensitive Files: {summary.get('sensitive_files_count', 0)}

"""
        self.results_text.insert(tk.END, header)
        
        # Category breakdown
        category_breakdown = summary.get('category_breakdown', {})
        if category_breakdown:
            self.results_text.insert(tk.END, "CATEGORY BREAKDOWN:\n")
            self.results_text.insert(tk.END, "-" * 50 + "\n")
            for category, count in category_breakdown.items():
                self.results_text.insert(tk.END, f"{category:<30} {count:>5} findings\n")
            self.results_text.insert(tk.END, "\n")
        
        # High-risk findings
        high_risk = summary.get('high_risk_findings', [])
        if high_risk:
            self.results_text.insert(tk.END, "HIGH-RISK FINDINGS:\n")
            self.results_text.insert(tk.END, "-" * 50 + "\n")
            for i, finding in enumerate(high_risk[:10], 1):
                self.results_text.insert(tk.END, f"{i:2d}. {finding.get('title', 'Unknown')}\n")
                self.results_text.insert(tk.END, f"    URL: {finding.get('url', '')}\n")
                reasoning = finding.get('analysis', {}).get('reasoning', '')
                if reasoning:
                    self.results_text.insert(tk.END, f"    Risk: {reasoning}\n")
                self.results_text.insert(tk.END, "\n")
        
        # Login pages
        login_pages = summary.get('login_pages', [])
        if login_pages:
            self.results_text.insert(tk.END, "LOGIN & ADMINISTRATIVE INTERFACES:\n")
            self.results_text.insert(tk.END, "-" * 50 + "\n")
            for i, page in enumerate(login_pages[:15], 1):
                risk = page.get('analysis', {}).get('risk_level', 'unknown')
                risk_indicator = "[HIGH]" if risk == 'high' else "[MED]" if risk == 'medium' else "[LOW]"
                self.results_text.insert(tk.END, f"{i:2d}. {risk_indicator} {page.get('title', 'Login Interface')}\n")
                self.results_text.insert(tk.END, f"    URL: {page.get('url', '')}\n\n")
        
        # Sensitive files
        sensitive_files = summary.get('sensitive_files', [])
        if sensitive_files:
            self.results_text.insert(tk.END, "SENSITIVE FILES & DOCUMENTS:\n")
            self.results_text.insert(tk.END, "-" * 50 + "\n")
            for i, file in enumerate(sensitive_files[:10], 1):
                self.results_text.insert(tk.END, f"{i:2d}. {file.get('title', 'Sensitive File')}\n")
                self.results_text.insert(tk.END, f"    URL: {file.get('url', '')}\n\n")
        
        # Footer
        footer = f"""
{'=' * 70}
SCAN COMPLETED SUCCESSFULLY
Reconnaissance Coverage: {summary.get('categories_scanned', 0)}/22 categories (Professional)
Performance: {scan_time:.1f}s total execution time
Status: Ready for next assessment
{'=' * 70}
"""
        self.results_text.insert(tk.END, footer)
    
    # UI Helper Methods
    def update_status(self, status, message):
        """Update status indicator"""
        colors = {'Ready': '#27ae60', 'Scanning': '#f39c12', 'Complete': '#27ae60', 'Error': '#e74c3c'}
        self.status_indicator.config(text=f"● {status}", foreground=colors.get(status, '#7f8c8d'))
        self.scan_info_label.config(text=message)
    
    def update_progress_text(self, text):
        """Update progress text with thread safety"""
        self.master.after(0, lambda: self.progress_text.config(text=text))
        logging.info(text)
    
    def update_workers_label(self, value):
        """Update workers label"""
        workers = int(float(value))
        self.workers_label.config(text=f"Current: {workers} workers")
    
    def update_config_display(self):
        """Update configuration display"""
        config_text = f"""CURRENT CONFIGURATION
{'=' * 40}

Performance Settings:
  Request Delay Range: {self.config['delay_range'][0]}-{self.config['delay_range'][1]} seconds
  Concurrent Workers: {self.config['max_workers']} threads  
  Request Timeout: {self.config['timeout']} seconds
  Batch Processing: {self.config['batch_size']} items

Reconnaissance Coverage:
  Total Categories: 22 professional categories
  Total Queries: {sum(len(dorks) for dorks in GOOGLE_DORKS.values())} specialized queries
  
Categories Included:
"""
        
        for i, category in enumerate(GOOGLE_DORKS.keys(), 1):
            config_text += f"  {i:2d}. {category} ({len(GOOGLE_DORKS[category])} queries)\n"
        
        config_text += f"""
Capabilities:
  - Comprehensive information gathering
  - Professional reporting & analysis  
  - Export to PDF, CSV, JSON formats
  - Hybrid analysis with direct probing
  - Stealth mode for low-profile scans
  - Bulk domain assessment support

Status: Ready for professional penetration testing
"""
        
        self.config_display.config(state=tk.NORMAL)
        self.config_display.delete(1.0, tk.END)
        self.config_display.insert(tk.END, config_text)
        self.config_display.config(state=tk.DISABLED)
    
    # Placeholder methods for remaining functionality
    def start_targeted_scan(self):
        messagebox.showinfo("Info", "Targeted scan functionality ready - implementation in progress")
    
    def start_bulk_assessment(self):
        messagebox.showinfo("Info", "Bulk assessment functionality ready - implementation in progress")
    
    def select_all_categories(self):
        for var in self.category_vars.values():
            var.set(True)
    
    def select_no_categories(self):
        for var in self.category_vars.values():
            var.set(False)
    
    def load_domains_file(self):
        filepath = filedialog.askopenfilename(filetypes=[("Text files", "*.txt"), ("All files", "*.*")])
        if filepath:
            try:
                with open(filepath, 'r') as f:
                    domains = f.read()
                self.bulk_domains_text.delete(1.0, tk.END)
                self.bulk_domains_text.insert(tk.END, domains)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load file: {e}")
    
    def clear_domains(self):
        self.bulk_domains_text.delete(1.0, tk.END)
    
    def save_configuration(self):
        try:
            self.config['delay_range'] = (self.min_delay_var.get(), self.max_delay_var.get())
            self.config['max_workers'] = int(self.max_workers_var.get())
            
            # Reinitialize components
            self.google_scraper = GoogleScraper(delay_range=self.config['delay_range'])
            
            self.update_config_display()
            messagebox.showinfo("Configuration", "Configuration updated successfully")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save configuration: {e}")
    
    def export_json(self):
        if not self.current_results:
            messagebox.showwarning("Warning", "No results to export")
            return
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filepath = filedialog.asksaveasfilename(
            defaultextension=".json",
            initialvalue=f"pentest_results_{timestamp}.json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        
        if filepath:
            try:
                with open(filepath, 'w', encoding='utf-8') as f:
                    json.dump(self.current_results, f, indent=2, ensure_ascii=False)
                messagebox.showinfo("Success", f"Results exported to {filepath}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to export: {e}")
    
    def export_csv(self):
        messagebox.showinfo("Info", "CSV export functionality ready - implementation in progress")
    
    def export_pdf(self):
        messagebox.showinfo("Info", "PDF export functionality ready - implementation in progress")
    
    def stop_scan(self):
        self.is_scanning = False
        self.update_status("Ready", "Scan stopped by user")
        self.reset_scan_ui()
    
    def reset_scan_ui(self):
        self.start_button.config(state=tk.NORMAL)
        self.stop_button.config(state=tk.DISABLED)
        self.progress_bar.config(value=0)

def main():
    """Launch the professional penetration testing GUI"""
    root = tk.Tk()
    
    # Set up logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
    
    app = ProfessionalPentestGUI(root)
    
    try:
        root.mainloop()
    except KeyboardInterrupt:
        logging.info("Application interrupted by user")
    except Exception as e:
        logging.error(f"Application error: {e}")
        messagebox.showerror("Fatal Error", f"Application error:\n{e}")

if __name__ == "__main__":
    main()
